{"version":3,"file":"server.js","mappings":";;;;;;;AAAa;AACb;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,iBAAiB,mBAAO,CAAC,GAAgB;AACzC,yBAAyB,mBAAO,CAAC,GAAkB;AACnD,mBAAmB,mBAAO,CAAC,GAAkB;AAC7C,8BAA8B,mBAAO,CAAC,GAAuB;AAC7D;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;ACtBA;;;;;;;ACAa;AACb;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,iBAAiB,mBAAO,CAAC,GAAgB;AACzC,iBAAiB,mBAAO,CAAC,GAAQ;AACjC,uBAAuB,mBAAO,CAAC,GAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,uDAAuD,aAAa;AACpE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,mDAAmD,YAAY,KAAK,aAAa;AACjF,yBAAyB;AACzB;AACA;AACA,uCAAuC,mCAAmC;AAC1E;AACA;AACA;AACA;AACA;AACA,oDAAoD,YAAY;AAChE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA,8EAA8E,kBAAkB;AAChG;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,yBAAyB;AACzB;AACA;AACA;;;;;;;;ACvKa;AACb;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,iBAAiB,mBAAO,CAAC,GAAgB;AACzC,mBAAmB,mBAAO,CAAC,GAAkB;AAC7C,8BAA8B,mBAAO,CAAC,GAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;;;;;;;AC9FA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;ACtBa;AACb,6BAA6C,EAAE,aAAa,CAAC;AAC7D,eAAe,mBAAO,CAAC,GAAc;AACrC,qBAAqB,mBAAO,CAAC,GAAc;AAC3C,2BAA2B,mBAAO,CAAC,GAA0B;AAC7D;AACA;AACA;AACA;AACA","sources":["webpack://sa-steam-proxy/./src/app.module.ts","webpack://sa-steam-proxy/external commonjs \"append-query\"","webpack://sa-steam-proxy/./src/steam-proxy.service.ts","webpack://sa-steam-proxy/./src/app.controller.ts","webpack://sa-steam-proxy/external commonjs \"@nestjs/platform-fastify\"","webpack://sa-steam-proxy/external commonjs \"@nestjs/common\"","webpack://sa-steam-proxy/external commonjs \"@nestjs/core\"","webpack://sa-steam-proxy/external commonjs \"undici\"","webpack://sa-steam-proxy/external commonjs \"@nestjs/schedule\"","webpack://sa-steam-proxy/webpack/bootstrap","webpack://sa-steam-proxy/./src/main.ts"],"sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppModule = void 0;\nconst common_1 = require(\"@nestjs/common\");\nconst app_controller_1 = require(\"./app.controller\");\nconst schedule_1 = require(\"@nestjs/schedule\");\nconst steam_proxy_service_1 = require(\"./steam-proxy.service\");\nlet AppModule = class AppModule {\n};\nexports.AppModule = AppModule;\nexports.AppModule = AppModule = __decorate([\n    (0, common_1.Module)({\n        imports: [schedule_1.ScheduleModule.forRoot()],\n        controllers: [app_controller_1.AppController],\n        providers: [steam_proxy_service_1.SteamProxyService],\n    })\n], AppModule);\n","module.exports = require(\"append-query\");","\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar SteamProxyService_1;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SteamProxyService = void 0;\nconst common_1 = require(\"@nestjs/common\");\nconst undici_1 = require(\"undici\");\nconst append_query_1 = require(\"append-query\");\nconst STEAM_API_HOST = 'http://api.steampowered.com';\nconst SAFE_PROBE_PATH = '/ISteamWebAPIUtil/GetServerInfo/v0001/';\nconst CACHE_TTL_MS = 10_000;\nconst ONE_MINUTE = 60_000;\nlet SteamProxyService = SteamProxyService_1 = class SteamProxyService {\n    constructor() {\n        this.logger = new common_1.Logger(SteamProxyService_1.name);\n        this.cache = new Map();\n        this.requestTimestamps = [];\n        this.isRateLimited = false;\n        this.lastFailurePath = '';\n        this.retryCounter = 0;\n        this.retryBackoff = 5;\n        this.metrics = {\n            total: 0,\n            success: 0,\n            failure: 0,\n            lastDurationMs: 0,\n        };\n        this.pool = new undici_1.Pool(STEAM_API_HOST, {\n            connections: 100,\n            pipelining: 1,\n            keepAliveTimeout: 60_000,\n        });\n        this.logger.log('SteamProxyService initialized using undici.Pool');\n    }\n    get healthStatus() {\n        this.cleanupOldRequests();\n        return {\n            healthy: !this.isRateLimited,\n            rateLimited: this.isRateLimited,\n            requestsPerMinute: this.requestTimestamps.length,\n            backoff: this.retryBackoff,\n            retryIn: this.retryBackoff - this.retryCounter,\n        };\n    }\n    getMetrics() {\n        return { ...this.metrics };\n    }\n    async proxy(originalPath) {\n        this.cleanupOldRequests();\n        this.requestTimestamps.push(Date.now());\n        this.metrics.total++;\n        const fullPath = (0, append_query_1.default)(originalPath);\n        const cacheKey = fullPath;\n        const now = Date.now();\n        const cached = this.cache.get(cacheKey);\n        if (cached && cached.expires > now && !this.isRateLimited) {\n            this.logger.debug(`Cache HIT: ${originalPath}`);\n            return cached.data;\n        }\n        if (this.isRateLimited) {\n            this.logger.warn(`Blocked by rate limit: ${originalPath}`);\n            return { error: 'rate_limited' };\n        }\n        const start = Date.now();\n        try {\n            const result = await this.pool.request({\n                method: 'GET',\n                path: fullPath,\n                headers: {\n                    'accept-encoding': 'gzip',\n                },\n            });\n            const duration = Date.now() - start;\n            this.metrics.lastDurationMs = duration;\n            const { statusCode, body } = result;\n            const data = await body.json().catch(() => body.text());\n            if (statusCode === 429) {\n                this.handleRateLimit(originalPath);\n                return { error: 'rate_limited' };\n            }\n            if (statusCode >= 400) {\n                this.metrics.failure++;\n                this.logger.warn(`Steam returned ${statusCode} on ${originalPath}`);\n                return { error: 'nok' };\n            }\n            this.metrics.success++;\n            this.cache.set(cacheKey, { data, expires: now + CACHE_TTL_MS });\n            return data;\n        }\n        catch (err) {\n            this.metrics.failure++;\n            this.metrics.lastDurationMs = Date.now() - start;\n            this.logger.error(`Steam fetch error: ${err.message}`);\n            return { error: 'nok' };\n        }\n    }\n    async checkRateLimiting() {\n        if (!this.isRateLimited)\n            return;\n        this.retryCounter++;\n        if (this.retryCounter < this.retryBackoff)\n            return;\n        this.retryCounter = 0;\n        try {\n            const res = await this.pool.request({\n                method: 'GET',\n                path: SAFE_PROBE_PATH,\n                headers: {\n                    'accept-encoding': 'gzip',\n                },\n            });\n            const retryAfter = res.headers['retry-after'];\n            if (retryAfter) {\n                const secs = parseInt(retryAfter, 10);\n                if (!isNaN(secs)) {\n                    this.retryBackoff = Math.max(secs, 5);\n                    this.logger.warn(`Retry-After header: ${secs}s`);\n                }\n            }\n            if (res.statusCode < 400) {\n                this.isRateLimited = false;\n                this.lastFailurePath = '';\n                this.retryBackoff = 5;\n                this.retryCounter = 0;\n                if (this.rateLimitStart) {\n                    const duration = ((Date.now() - this.rateLimitStart) / 1000).toFixed(1);\n                    this.logger.log(`Rate limit lifted after ${duration}s`);\n                    this.rateLimitStart = undefined;\n                }\n            }\n            else if (res.statusCode === 429) {\n                this.retryBackoff *= 2;\n                this.logger.warn(`Still rate-limited. Increasing backoff to ${this.retryBackoff}s.`);\n            }\n            else {\n                this.logger.warn(`Unexpected probe status: ${res.statusCode}`);\n            }\n        }\n        catch (err) {\n            this.logger.error(`Rate-limit probe error: ${err.message}`);\n        }\n    }\n    cleanupOldRequests() {\n        const cutoff = Date.now() - ONE_MINUTE;\n        this.requestTimestamps = this.requestTimestamps.filter(t => t > cutoff);\n    }\n    handleRateLimit(path) {\n        this.metrics.failure++;\n        this.lastFailurePath = path;\n        if (!this.isRateLimited) {\n            this.isRateLimited = true;\n            this.rateLimitStart = Date.now();\n        }\n    }\n};\nexports.SteamProxyService = SteamProxyService;\nexports.SteamProxyService = SteamProxyService = SteamProxyService_1 = __decorate([\n    (0, common_1.Injectable)(),\n    __metadata(\"design:paramtypes\", [])\n], SteamProxyService);\n","\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppController = void 0;\nconst common_1 = require(\"@nestjs/common\");\nconst schedule_1 = require(\"@nestjs/schedule\");\nconst steam_proxy_service_1 = require(\"./steam-proxy.service\");\nlet AppController = class AppController {\n    constructor(steamProxy) {\n        this.steamProxy = steamProxy;\n    }\n    getHealth(res) {\n        const health = this.steamProxy.healthStatus;\n        res\n            .status(health.rateLimited ? 429 : 200)\n            .set({\n            'X-RateLimit-Status': health.rateLimited ? 'limited' : 'ok',\n            'X-Requests-Per-Minute': health.requestsPerMinute.toString(),\n            'X-Backoff': health.backoff.toString(),\n            'X-Retry-In': health.retryIn.toString(),\n        })\n            .send(health.rateLimited ? 'limit' : 'ok');\n    }\n    getMetrics() {\n        return this.steamProxy.getMetrics();\n    }\n    async proxy(req, res) {\n        const result = await this.steamProxy.proxy(req.originalUrl);\n        if (result?.error) {\n            res\n                .status(result.error === 'rate_limited' ? 429 : 500)\n                .set('X-RateLimit-Status', 'limited')\n                .send(result.error);\n        }\n        else {\n            res.status(200).send(result);\n        }\n    }\n    checkRateLimit() {\n        this.steamProxy.checkRateLimiting();\n    }\n    restart() {\n        console.log('[CRON] Midnight restart');\n        process.exit();\n    }\n};\nexports.AppController = AppController;\n__decorate([\n    (0, common_1.Get)('/healthz'),\n    __param(0, (0, common_1.Res)()),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", void 0)\n], AppController.prototype, \"getHealth\", null);\n__decorate([\n    (0, common_1.Get)('/metrics'),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", void 0)\n], AppController.prototype, \"getMetrics\", null);\n__decorate([\n    (0, common_1.Get)('/*'),\n    __param(0, (0, common_1.Req)()),\n    __param(1, (0, common_1.Res)()),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object, Object]),\n    __metadata(\"design:returntype\", Promise)\n], AppController.prototype, \"proxy\", null);\n__decorate([\n    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_5_MINUTES),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", void 0)\n], AppController.prototype, \"checkRateLimit\", null);\n__decorate([\n    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_MIDNIGHT),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", void 0)\n], AppController.prototype, \"restart\", null);\nexports.AppController = AppController = __decorate([\n    (0, common_1.Controller)(),\n    __metadata(\"design:paramtypes\", [steam_proxy_service_1.SteamProxyService])\n], AppController);\n","module.exports = require(\"@nestjs/platform-fastify\");","module.exports = require(\"@nestjs/common\");","module.exports = require(\"@nestjs/core\");","module.exports = require(\"undici\");","module.exports = require(\"@nestjs/schedule\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"@nestjs/core\");\nconst app_module_1 = require(\"./app.module\");\nconst platform_fastify_1 = require(\"@nestjs/platform-fastify\");\nasync function bootstrap() {\n    const app = await core_1.NestFactory.create(app_module_1.AppModule, new platform_fastify_1.FastifyAdapter());\n    await app.listen(8080, '0.0.0.0');\n}\nbootstrap();\n"],"names":[],"sourceRoot":""}